/* eslint-disable @typescript-eslint/no-require-imports */
'use strict';

const express = require('express');
const { exec } = require('child_process');
const fs = require('fs');
const os = require('os');
const path = require('path');
const { Storage } = require('@google-cloud/storage');
const { Firestore, FieldValue } = require('@google-cloud/firestore');

const app = express();
const storage = new Storage();
const firestore = new Firestore();

app.use(express.json());

// Health check endpoint for Cloud Run service checks.
app.get('/health', (_req, res) => {
  res.status(200).send('OK');
});

// Converts PDF pages to JPEG files using pdftoppm and updates Firestore on completion.
app.post('/convert', async (req, res) => {
  const { bucketName, filePath, documentId, userId } = req.body || {};

  if (!bucketName || !filePath || !documentId || !userId) {
    return res
      .status(400)
      .json({ error: 'Missing required fields: bucketName, filePath, documentId, userId' });
  }

  const tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'docsflip-'));
  const tempPdfPath = path.join(tempDir, 'input.pdf');
  const outputPrefix = path.join(tempDir, 'page');

  try {
    const bucket = storage.bucket(bucketName);
    await bucket.file(filePath).download({ destination: tempPdfPath });

    await new Promise((resolve, reject) => {
      const cmd = `pdftoppm -jpeg -r 150 -jpegopt quality=80 "${tempPdfPath}" "${outputPrefix}"`;
      exec(cmd, (error, _stdout, stderr) => {
        if (error) {
          reject(new Error(`pdftoppm failed: ${stderr || error.message}`));
          return;
        }
        resolve();
      });
    });

    const pageFiles = fs
      .readdirSync(tempDir)
      .filter((file) => file.startsWith('page-') && file.endsWith('.jpg'))
      .sort();

    if (pageFiles.length === 0) {
      throw new Error('No page images were generated by pdftoppm');
    }

    const pageUrls = [];

    for (let i = 0; i < pageFiles.length; i += 1) {
      const pageNumber = i + 1;
      const paddedNum = String(pageNumber).padStart(3, '0');
      const destPath = `documents/${userId}/${documentId}/pages/page_${paddedNum}.jpg`;
      const localPath = path.join(tempDir, pageFiles[i]);

      await bucket.upload(localPath, {
        destination: destPath,
        metadata: {
          contentType: 'image/jpeg',
          cacheControl: 'public, max-age=31536000',
        },
      });

      await bucket.file(destPath).makePublic();
      pageUrls.push(`https://storage.googleapis.com/${bucketName}/${destPath}`);
    }

    await firestore.collection('documents').doc(documentId).update({
      status: 'ready',
      pageCount: pageFiles.length,
      pageUrls,
      pdfUrl: `https://storage.googleapis.com/${bucketName}/${filePath}`,
      updatedAt: FieldValue.serverTimestamp(),
    });

    // Clean up original source PDF after successful conversion.
    try {
      await bucket.file(filePath).delete();
    } catch (deleteError) {
      console.warn('Could not delete original PDF:', deleteError.message);
    }

    fs.rmSync(tempDir, { recursive: true, force: true });
    return res.status(200).json({ success: true, pageCount: pageFiles.length, documentId });
  } catch (error) {
    try {
      await firestore.collection('documents').doc(documentId).update({
        status: 'error',
        updatedAt: FieldValue.serverTimestamp(),
      });
    } catch (firestoreError) {
      console.error('Also failed to update Firestore error state:', firestoreError.message);
    }

    try {
      fs.rmSync(tempDir, { recursive: true, force: true });
    } catch {
      // Ignore temp cleanup failures.
    }

    return res.status(500).json({ error: error.message, documentId });
  }
});

const PORT = process.env.PORT || 8080;
app.listen(PORT, () => {
  console.log(`Docsflip converter service listening on port ${PORT}`);
});
